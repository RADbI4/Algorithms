"""
Продолжаю практиковаться в функциональном программировании.
Продолжаю поиск функции, которая принимает в себя набор функций, затем последовательно
выполняет их, как implosive_attractor. Его недостаток в том, что мне приходится сразу
передавать туда аргументы, но я хотел бы заморозить функции, которые я потом хотел бы применить ещё раз.
"""
from datetime import datetime
from functools import partial, reduce
import traceback
import operator


"""
Очень часто мне приходится прибегать к конструкциям вида: описанных мною ещё в практике №1
"""
# constructor = lambda last_func, primary_func: lambda *args: partial(last_func(primary_func(*args)))
#
# list_engine = constructor(list, map)
# zip_engine = constructor(dict, zip)
# filter_engine = constructor(list, filter)

"""
Функция должна выглядеть примерно так: constructor(list, map, sum)([1,2,3]), она должна принимать сколько угодно
много функций, за основу возьму функции из практики 9 по структурам данных
"""
general_constructor = lambda last_func, first_func: lambda *args: last_func(first_func(*args))
map_engine = partial(lambda *args: sum(list(map(*args))))

"""
Имплозивный Аттрактор, версия 2.

Подобно чёрной дыре поглащает аргументы и функции. 

Когда очередная функция выполнила вычисления, он
немедленно отправляет результаты вычисления в следующую функцию как аргументы, проваливаясь внутрь самого
себя до тех пор, пока последняя функция не вернёт свои значения- это и будет тем, что выведет Аттрактор.

Для того, чтобы функция работала правильно- необходимо знать сколько аргументов принимает "нулевая" функция, 
сколько она их возвращает и какие аргументы принимает след. функция и .т.д по цепочке.

Нулевая функция является детонатором имплозивного взрыва. Как только мы передаём аргументы- мы запускаем цепочку вычислений.

Если цепочка нарушается, то имплозия не происходит и интерпретатор вернёт ошибку.
Цепочка нарушается, если: 
-передано не то кол-во аргументов, которое принимает след функция
-1 или все типы данных переданные след. функции не соответствуют ожидаемым

Аттрактор делает код удобнее к чтению, а каждую отдельно взятую функцию легче тестировать, чем один большой скрипт.
"""
implosive_attractor = lambda *funcs: partial(lambda *args: reduce(lambda x, f: f(x), funcs[1:], funcs[0](*args)))

# Что делаем с аргументами? Сначала маппим, потом в лист, а потом находим сумму, код прост в чтении.
sum_generator = implosive_attractor(map, list, sum)

test_data = [1, 2, 3, 4, 5]
a = lambda x: x*2

if __name__ == "__main__":
    start_time = datetime.now()
    print(sum_generator(a, test_data))  # 30
    """
    Или, чтобы не генерировать новый объект в памяти:
    список функций, который будут выполнены с лева на право: map, list, sum
    Чтобы начать имплозию, необходимо передать "детонатор"- аргументы для map- это функцция "a" и список- test_data
    """
    print(implosive_attractor(map, list, sum)(a, test_data))
    print(datetime.now() - start_time)


